// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.32.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';

// Rust type: RustOpaqueMoi<Mutex < Connection >>
@sealed
class MutexConnection extends RustOpaque {
  MutexConnection.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MutexConnection.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_MutexConnection,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_MutexConnection,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MutexConnectionPtr,
  );
}

// Rust type: RustOpaqueMoi<Mutex < RepoDatabaseRead >>
@sealed
class MutexRepoDatabaseRead extends RustOpaque {
  MutexRepoDatabaseRead.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MutexRepoDatabaseRead.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_MutexRepoDatabaseRead,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_MutexRepoDatabaseRead,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_MutexRepoDatabaseReadPtr,
  );
}

/// Repo
class LocalDb {
  final MutexRepoDatabaseRead repo;

  const LocalDb({
    required this.repo,
  });

  Future<String?> getAlbum({required UuidValue albumId, dynamic hint}) =>
      RustLib.instance.api
          .localDbGetAlbum(that: this, albumId: albumId, hint: hint);

  Future<List<UuidValue>> getAlbumsByTag(
          {required String tag, required bool recursive, dynamic hint}) =>
      RustLib.instance.api.localDbGetAlbumsByTag(
          that: this, tag: tag, recursive: recursive, hint: hint);

  Future<List<TagItem>> getTags({dynamic hint}) =>
      RustLib.instance.api.localDbGetTags(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<LocalDb> newInstance({required String path, dynamic hint}) =>
      RustLib.instance.api.localDbNew(path: path, hint: hint);

  @override
  int get hashCode => repo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocalDb &&
          runtimeType == other.runtimeType &&
          repo == other.repo;
}

/// API
class LocalStore {
  final MutexConnection conn;

  const LocalStore.raw({
    required this.conn,
  });

  Future<void> clear({String? category, dynamic hint}) => RustLib.instance.api
      .localStoreClear(that: this, category: category, hint: hint);

  Future<String?> get(
          {required String category, required String key, dynamic hint}) =>
      RustLib.instance.api
          .localStoreGet(that: this, category: category, key: key, hint: hint);

  Future<void> insert(
          {required String category,
          required String key,
          required String value,
          dynamic hint}) =>
      RustLib.instance.api.localStoreInsert(
          that: this, category: category, key: key, value: value, hint: hint);

  factory LocalStore({required String root, dynamic hint}) =>
      RustLib.instance.api.localStoreNew(root: root, hint: hint);

  @override
  int get hashCode => conn.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocalStore &&
          runtimeType == other.runtimeType &&
          conn == other.conn;
}

/// Preferences
class NativePreferenceStore {
  final MutexConnection conn;

  const NativePreferenceStore.raw({
    required this.conn,
  });

  String? get({required String key, dynamic hint}) => RustLib.instance.api
      .nativePreferenceStoreGet(that: this, key: key, hint: hint);

  factory NativePreferenceStore({required String root, dynamic hint}) =>
      RustLib.instance.api.nativePreferenceStoreNew(root: root, hint: hint);

  void remove({required String key, dynamic hint}) => RustLib.instance.api
      .nativePreferenceStoreRemove(that: this, key: key, hint: hint);

  void removePrefix({required String prefix, dynamic hint}) =>
      RustLib.instance.api.nativePreferenceStoreRemovePrefix(
          that: this, prefix: prefix, hint: hint);

  void set({required String key, required String value, dynamic hint}) =>
      RustLib.instance.api.nativePreferenceStoreSet(
          that: this, key: key, value: value, hint: hint);

  @override
  int get hashCode => conn.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NativePreferenceStore &&
          runtimeType == other.runtimeType &&
          conn == other.conn;
}

class TagItem {
  final String name;
  final List<String> children;

  const TagItem({
    required this.name,
    required this.children,
  });

  @override
  int get hashCode => name.hashCode ^ children.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TagItem &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          children == other.children;
}
